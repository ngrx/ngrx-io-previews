{
  "id": "guide/store/recipes/adding-ngrx-to-existing-apps",
  "title": "Adding NgRx to existing Angular applications",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/store/recipes/adding-ngrx-to-existing-apps.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"adding-ngrx-to-existing-angular-applications\">Adding NgRx to existing Angular applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#adding-ngrx-to-existing-angular-applications\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"how-do-apps-without-ngrx-typically-function\">How do apps without NgRx typically function?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#how-do-apps-without-ngrx-typically-function\"><i class=\"material-icons\">link</i></a></h2>\n<p>Most of the applications out there do not use NgRx. But most applications follow the typical patterns and solve common problems, which are:</p>\n<ol>\n<li>Retrieving data from a remote API</li>\n<li>Saving that data in a component state (say, on some property like <code>userList</code>) </li>\n<li>Display that data in the UI</li>\n<li>Make alterations of the data in the backend (add, update or delete entries)</li>\n<li>Again, display the results of those actions in the UI (success messages, updated lists of data, and so on)</li>\n</ol>\n<p>Usually to do that, developers write services which inject the Angular's <code>HttpClient</code>, write methods to retrieve or modify specific parts of the data, then inject those services in the components and use them, tightly coupled with the components. Let's see an example of such a \"conventional\" component:</p>\n<code-example header=\"to-do-list.component.ts\">\n@Component({\n    <a href=\"api/store/testing/MockSelector#selector\" class=\"code-anchor\">selector</a>: 'app-to-do-list',\n    template: `\n      &#x3C;div>\n        &#x3C;ul>\n          &#x3C;li *ngFor=\"let todo of todos\">\n            &#x3C;span>{{ todo.text }}&#x3C;/span>\n            &#x3C;button (click)=\"removeTodo(todo.id)\">X&#x3C;/button>\n          &#x3C;/li>\n        &#x3C;/ul>\n        &#x3C;div>\n          &#x3C;input #todoName placeholder=\"<a href=\"api/data/ChangeSetOperation#Add\" class=\"code-anchor\">Add</a> new To-Do Item\"/>\n          &#x3C;button (click)=\"addToDo(#todoName.value)\">Save To-Do Item&#x3C;/button>\n      &#x3C;/div>\n    `\n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class ToDoListComponent implements OnInit {\n    todos: ToDo[] = [];\n    \n    constructor(\n        private readonly todoService: TodoService,\n        private toastService: ToastService,\n    ) {}\n    \n    ngOnInit() {\n        this.getToDos();\n    }\n    \n    addToDo(toDoName: string) {\n        this.todoService.addToDo().subscribe(\n            (createdToDo) => {\n                this.todos = [...this.todos, createdToDo];\n                this.toastService.displaySuccessMessage('To Do Item Successfully <a href=\"api/data/ChangeType#Added\" class=\"code-anchor\">Added</a>');\n            },\n            error => this.toastService.displayErrorMessage(error.message),\n        );\n    }\n    \n    removeToDo(toDoId: number) {\n        this.todoService.removeToDo(toDoId).subscribe(\n            () => {\n                this.todos = this.todos.filter(todo => todo.id !== toDoId);\n                this.toastService.displaySuccessMessage('To Do Item Successfully Removed');\n            },\n            error => this.toastService.displayErrorMessage(error.message),\n        );\n    }\n    \n    private getToDos() {\n        this.todoService.getToDos().subscribe(\n            todos => this.todos = todos,\n            error => this.toastService.displayErrorMessage(error.message),\n        );\n    }\n}\n</code-example>\n<p>Now this component is dealing with a fairly large chunk of the application state: it stores the To-Do items list, it allows to add new items and remove them. Of course, every time we do any modifications, we have to also manually update the state (the <code>todos</code> array) to accurately reflect the new state of the application. </p>\n<p>Now this component does lots of heavy lifting that does not really belong here. Ideally, the component will just have a list of <code>todos</code> served to it, being updated reactively every time there is a modification to the state. This is where NgRsx comes into the mix.</p>\n<h2 id=\"switching-to-ngrx\">Switching to NgRx<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#switching-to-ngrx\"><i class=\"material-icons\">link</i></a></h2>\n<p>We are going to overwrite the component using NgRx. We are not going to overwrite the service, as it is performing its duties fairly well. Remember, <strong>NgRx is not there to replace services</strong>. Instead, it is meant to decouple services from te components, so we only deal with the incoming data in them, rather then doing imperative logic to keep the state up-to-date.</p>\n<p>We are going to add <code>@ngrx/store</code> and <code>@ngrx/effects</code> (because we are going to use HTTP calls). </p>\n<p>Next, let's add a <code><a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a></code> folder in the root directory of our application, and add several files to them: <code>state.ts</code>, <code>actions.ts</code>, <code>reducer.ts</code> and <code>effects.ts</code>. We are going to move our state handling logic into those files.</p>\n<h3 id=\"understanding-the-state\">Understanding the state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#understanding-the-state\"><i class=\"material-icons\">link</i></a></h3>\n<p>First of all, let's understand what features we have, and what state is stored under each feature. In our case, it is simple: we have a <code>ToDos</code> feature, which holds an array of <code>todos</code>. Let's create interfaces to describe our application state inside the <code>state.ts</code> file:</p>\n<code-example header=\"state.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> interface ToDo {\n    <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: number;\n    text: string;\n}\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> interface ToDosState {\n    list: ToDo[];\n}\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> interface AppState {\n    toDos: ToDosState;\n}\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const todosInitialState: ToDosState = {\n    list: [],\n};\n</code-example>\n<p>In this file, we have explained that our application-wide state has a feature named <code>toDos</code>, and that state as a <code>list</code> of <code>ToDo</code> items, which initially is an empty array. </p>\n<h3 id=\"understanding-how-the-state-can-be-modified\">Understanding how the state can be modified<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#understanding-how-the-state-can-be-modified\"><i class=\"material-icons\">link</i></a></h3>\n<p>Now we have a schema of how our state looks, Let's now describe in what ways can it be modified. To do that, let's create some actions in the <code>actions.ts</code>. We are going to need actions for the following things:</p>\n<ol>\n<li>Retrieving <code>todos</code> from the API. For that, we need three actions: a command to retrieve the list, a success action, and an error action, to describe what happens to the application state o each of those scenarios</li>\n<li>Adding a <code>todo</code> item (again, three actions)</li>\n<li>Removing a <code>todo</code> item (three actions)</li>\n</ol>\n<p>Here is what our <code>actions.ts</code> file might look like:</p>\n<code-example header=\"actions.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>, <a href=\"api/store/props\" class=\"code-anchor\">props</a> } from '@ngrx/store';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { ToDo } from './<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const loadToDos = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>('[ToDo List] Load To-Dos'); \n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const loadToDosSuccess = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] Load To-Dos Success',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: ToDo}>(),\n);\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const loadToDosError = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] Load To-Dos Error',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: Error}>(),\n);\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const addToDo = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] <a href=\"api/data/ChangeSetOperation#Add\" class=\"code-anchor\">Add</a> To-Do',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: Omit&#x3C;ToDo, '<a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>'>}>(), // we don't have an idea when we start creating a todo item\n); \n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const addToDoSuccess = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] <a href=\"api/data/ChangeSetOperation#Add\" class=\"code-anchor\">Add</a> To-Do Success',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: ToDo}>(), // when the todo item is successfully created, the backend will return a full todo with <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>\n);\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const addToDoError = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] <a href=\"api/data/ChangeSetOperation#Add\" class=\"code-anchor\">Add</a> To-Do Error',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: Error}>(),\n);\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const removeToDo = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] Remove To-Do',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: number}>(), // the <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a> of the todo item ot be deleted\n); \n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const removeToDoSuccess = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] Remove To-Do Success',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: number}>(), //the same <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a> to use in the reducer\n);\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const removeToDoError = <a href=\"api/store/createAction\" class=\"code-anchor\">createAction</a>(\n    '[ToDo List] Remove To-Do Error',\n    <a href=\"api/store/props\" class=\"code-anchor\">props</a>&#x3C;{payload: Error}>(),\n);\n</code-example>\n<p>Now this part is very straightforward, it only describes in <em>what ways</em> can the state be modified. Now let's describe <em>how</em> is it modified.</p>\n<h3 id=\"modifying-the-state\">Modifying the state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#modifying-the-state\"><i class=\"material-icons\">link</i></a></h3>\n<p>It is high time to write a reducer so that we can register our store:</p>\n<code-example header=\"reducer.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/store/createReducer\" class=\"code-anchor\">createReducer</a>, <a href=\"api/store/on\" class=\"code-anchor\">on</a>, <a href=\"api/store/Action\" class=\"code-anchor\">Action</a> } from '@ngrx/store';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { ToDosState, todosInitialState } from './<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> * as todos './actions';\n\nconst _todosReducer = <a href=\"api/store/createReducer\" class=\"code-anchor\">createReducer</a>(\n    todosInitialState,\n    <a href=\"api/store/on\" class=\"code-anchor\">on</a>(todos.loadToDosSuccess, (<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action) => ({...state, list: action.payload})),\n    <a href=\"api/store/on\" class=\"code-anchor\">on</a>(todos.addToDoSuccess, (<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action) => ({...state, list: [...state.list, action.payload]})),\n    <a href=\"api/store/on\" class=\"code-anchor\">on</a>(todos.removeToDoSuccess, (<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action) => ({...state, list: list.filter(todo => todo.id !== action.payload)})),\n);\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> function todosReducer(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>: ToDosState, action: <a href=\"api/store/Action\" class=\"code-anchor\">Action</a>) {\n    return _todosReducer(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action);\n}\n</code-example>\n<p>The, we can register our reducer with the <code><a href=\"api/store/StoreModule\" class=\"code-anchor\">StoreModule</a></code> in our <code>AppModule</code>:</p>\n<code-example header=\"app.module.ts\">\n@NgModule({\n    // other <a href=\"api/data/EntityDefinition#metadata\" class=\"code-anchor\">metadata</a>\n    imports: [\n        // other imports,\n        StoreModule.forRoot({toDos: todosReducer}),\n    ] \n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class AppModule {}\n</code-example>\n<p>Notice we only update the store on <code>success</code> actions: we will first call the API service, it will successfully update the database, and only then will we update our application state. To do this, we are going to write an <code><a href=\"api/effects/Effect\" class=\"code-anchor\">Effect</a></code> in the <code>effects.ts</code> file. It will:</p>\n<ol>\n<li>Handle the loading of the <code>todos</code> (success and error scenarios)</li>\n<li>Handle adding a <code>todo</code> item (success and error scenarios)</li>\n<li>Handle removing a <code>todo</code> item (success and error scenarios)</li>\n<li>Also handle the display of success/error messages</li>\n</ol>\n<p>Let's write the class:</p>\n<code-example header=\"effects.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { Injectable } from '@angular/core';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>, <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>, <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a> } from '@ngrx/effects';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { of } from 'rxjs';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { mergeMap, map, catchError, tap } from 'rxjs/operators';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { ToastService } from '../<a href=\"api/data/EntityDataService#services\" class=\"code-anchor\">services</a>/toast.service';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { TodosService } from '../<a href=\"api/data/EntityDataService#services\" class=\"code-anchor\">services</a>/todos.service';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> * as todos from './actions';\n\n@Injectable()\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class TodosEffects {\n    \n    // handle <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a> of the todos array\n    loadTodos$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() => this.actions$.pipe(\n        <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(todos.loadToDos),\n        mergeMap(() => this.todosService.getToDos().pipe(\n            map(todos => todos.loadToDosSuccess({payload: todos})),\n            catchError(error => of(todos.loadToDosError({payload: error}))),\n        )),\n    ));    \n    \n    // handle adding a todo item\n    addTodo$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() => this.actions$.pipe(\n        <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(todos.addToDo),\n        mergeMap(({payload}) => this.todosService.addToDo().pipe(\n            map(createdToDo => todos.addToDoSuccess({payload: createdToDo})),\n            catchError(error => of(todos.addToDosError({payload: error}))),\n        )),\n    ));  \n    \n    // handle removing a todo item\n    addTodo$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() => this.actions$.pipe(\n        <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(todos.removeToDo),\n        mergeMap(({payload}) => this.todosService.removeToDo().pipe(\n            map(() => todos.removeToDoSuccess({payload})), // send the same <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a> as we received\n            catchError(error => of(todos.removeToDosError({payload: error}))),\n        )),\n    ));    \n    \n    // handle the success messages\n    todoSuccessMessages$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() => this.actions$.pipe(\n        <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(todos.addToDoSuccess, todos.removeToDoSuccess), // we can handle multiple actions in an <a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a>\n        tap(message => this.toastService.displayErrorMessage(message))\n    ), {dispatch: false}); // set dispatch: false as we do not need to map to another action, only perform a side <a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a>   \n    \n    // handle the error messages\n    todoSuccessMessages$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() => this.actions$.pipe(\n        <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(todos.addToDoSuccess, todos.removeToDoSuccess),\n        tap(message => this.toastService.displaySuccessMessage(message))\n    ), {dispatch: false}); \n    \n    constructor(\n        private readonly actions$: <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>,\n        private readonly todosService: TodosService,\n        private readonly toastService: ToastService,\n    ) {}\n}\n</code-example>\n<p>So we moved the most heavy part of the state management logic from the component to the effect: working with the remote API. We can now register our effect in <code>AppModule</code>:</p>\n<code-example header=\"app.module.ts\">\n@NgModule({\n    // other <a href=\"api/data/EntityDefinition#metadata\" class=\"code-anchor\">metadata</a>\n    imports: [\n        // other imports,\n        EffectsModule.forRoot([TodosEffects]),\n    ] \n})\n</code-example>\n<p>Before we use the data in our component, one last step we have to take is to create a selector to actually get the <code>todos</code> list in the component. Let's do this in <code>selector.ts</code>:</p>\n<code-example header=\"selectors.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/store/createFeatureSelector\" class=\"code-anchor\">createFeatureSelector</a>, <a href=\"api/store/createSelector\" class=\"code-anchor\">createSelector</a> } from '@ngrx/store';\n\nconst todos = <a href=\"api/store/createFeatureSelector\" class=\"code-anchor\">createFeatureSelector</a>('toDos');\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const allTodos = <a href=\"api/store/createSelector\" class=\"code-anchor\">createSelector</a>(todos, <a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a> => state.list);\n</code-example>\n<p>Now let's move on and refactor our component:</p>\n<code-example header=\"to-do-list.component.ts\">\n@Component({\n    <a href=\"api/store/testing/MockSelector#selector\" class=\"code-anchor\">selector</a>: 'app-to-do-list',\n    template: `\n      &#x3C;div>\n        &#x3C;ul>\n          &#x3C;li *ngFor=\"let todo of (todos$ | async)\">\n            &#x3C;span>{{ todo.text }}&#x3C;/span>\n            &#x3C;button (click)=\"removeTodo(todo.id)\">X&#x3C;/button>\n          &#x3C;/li>\n        &#x3C;/ul>\n        &#x3C;div>\n          &#x3C;input #todoName placeholder=\"<a href=\"api/data/ChangeSetOperation#Add\" class=\"code-anchor\">Add</a> new To-Do Item\"/>\n          &#x3C;button (click)=\"addToDo(#todoName.value)\">Save To-Do Item&#x3C;/button>\n      &#x3C;/div>\n    `\n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class ToDoListComponent implements OnInit {\n    todos$: this.store.select(fromTodos.allTodos);\n    \n    constructor(\n        private readonly store: <a href=\"api/store/Store\" class=\"code-anchor\">Store</a>,\n    ) {}\n    \n    ngOnInit() {\n        this.store.dispatch(fromTodos.loadToDos());\n    }\n    \n    addToDo(toDoName: string) {\n        this.store.dispatch(fromTodos.addToDo({payload: {name: toDoName}}));\n    }\n    \n    removeToDo(toDoId: number) {\n        this.store.dispatch(fromTodos.removeToDo({payload:toDoId}));\n    }\n    \n    private getToDos() {\n        this.todoService.getToDos().subscribe(\n            todos => this.todos = todos,\n            error => this.toastService.displayErrorMessage(error.message),\n        );\n    }\n}\n</code-example>\n<p>As you can see, the <code><a href=\"api/store/Store\" class=\"code-anchor\">Store</a></code> now acts as a sort of a facade class, which separates the component from the application state, providing slices of state through selectors and allowing modifications via actions dispatchers. The refactoring took us N steps:</p>\n<ol>\n<li>Abstract away the state handling logic into reducers and actions</li>\n<li>Create selectors to access the state in the components</li>\n<li>Move the API calls (side-effects) into <code>Effects</code> classes</li>\n<li>Change the template a bit to use the <code>async</code> pipe</li>\n</ol>\n<p>And that is it. using the same logic, we can refactor all the components in an application.</p>\n<h2 id=\"lazy-loading\">Lazy Loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n<p>Another concern is modules that are being lazy loaded. Usually, those modules have their own state, and it would not be beneficial to put their reducers/actions/effects/selectors in the global state, both uin terms of code quality (those files and classed will become extremely bloated) and in terms of performance/bundle size (no need to load and initialize parts of state that might never be accessed). </p>\n<p>So the next move after creating the application state is to take care about lazy-loaded feature states. Say we have an \"admin\" feature in the application, that is being lazy loaded separately. First, we can define it in out application interface:</p>\n<code-example header=\"state.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> interface ToDosState {\n    list: ToDo[];\n}\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> interface AdminState {\n    // <a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a> that is related to the \"admin\" feature\n}\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> interface AppState {\n    toDos: ToDosState;\n    admin?: AdminState; // optional as at some point it can be undefined before the AdminModule is lazy <a href=\"api/data/EntityCollection#loaded\" class=\"code-anchor\">loaded</a>\n}\n</code-example>\n<p>Now we can create the same \"state\" folder with respective files (for reducer, actions,. effects and selectors) in the admin module directory, add all the relevant logic, and register it in the <code>AdminModule</code> class:</p>\n<code-example header=\"app.module.ts\">\n@NgModule({\n    // other <a href=\"api/data/EntityDefinition#metadata\" class=\"code-anchor\">metadata</a>\n    imports: [\n        // other imports,\n        StoreModule.forFeature({admin: adminReducer}),\n        EffectsModule.forRoot([AdminEffects]),\n    ] \n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class AdminModule {}\n</code-example>\n<p>We can then extend all those refactorings to all the lazy-loaded feature modules in our application. An important thing to remember is that the state from a lazy loaded module will be undefined if the user has not accessed those routes, meaning that if we would like to, say, use a piece of data from the <code>Admin</code> feature in the <code>To Do List Page</code>, we might encounter a problem if the user has not previously visited the <code>Admin Module</code>, thus meaning that data would probably better belong in the root state. So remember to take this into consideration when building lazy loaded features with NgRx.</p>\n<h2 id=\"further-changes\">Further changes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/recipes/adding-ngrx-to-existing-apps#further-changes\"><i class=\"material-icons\">link</i></a></h2>\n<p>If we are working with large lists of data performing different operations (adding one item, removing many items, updating many or one items and so on), then our application can also benefit from @ngrx/entity. A small example of how it can benefit our To-Do list application in the reducer:</p>\n<code-example header=\"reducer.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/store/createReducer\" class=\"code-anchor\">createReducer</a>, <a href=\"api/store/on\" class=\"code-anchor\">on</a>, <a href=\"api/store/Action\" class=\"code-anchor\">Action</a> } from '@ngrx/store';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/entity/EntityState\" class=\"code-anchor\">EntityState</a>, <a href=\"api/entity/createEntityAdapter\" class=\"code-anchor\">createEntityAdapter</a> } from '@ngrx/entity';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { ToDosState, todosInitialState } from './<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> * as todos './actions';\n\nconst todosAdapter = <a href=\"api/entity/createEntityAdapter\" class=\"code-anchor\">createEntityAdapter</a>&#x3C;ToDo>();\n\nconst _todosReducer = <a href=\"api/store/createReducer\" class=\"code-anchor\">createReducer</a>(\n    todosAdapter.getInitialState(),\n    <a href=\"api/store/on\" class=\"code-anchor\">on</a>(todos.loadToDosSuccess, (<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action) => todosAdapter.setAll(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action.payload)),\n    <a href=\"api/store/on\" class=\"code-anchor\">on</a>(todos.addToDoSuccess, (<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action) => todosAdapter.addOne(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action.payload)),\n    <a href=\"api/store/on\" class=\"code-anchor\">on</a>(todos.removeToDoSuccess, (<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action) => todosAdapter.removeOne(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action.payload)),\n);\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> function todosReducer(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>: ToDosState, action: <a href=\"api/store/Action\" class=\"code-anchor\">Action</a>) {\n    return _todosReducer(<a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>, action);\n}\n</code-example>\n<p>With this, the reducer function looks way more organized and clean. You can read more about <code>@ngrx/entity</code> <a href=\"https://ngrx.io/guide/entity\">here</a>.</p>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/data/ChangeSetOperation#Add\n - api/data/ChangeType#Added\n - api/data/EntityCollection#loaded\n - api/data/EntityCollection#loading\n - api/data/EntityDataService#services\n - api/data/EntityDefinition#metadata\n - api/data/UpdateResponseData#id\n - api/effects/Actions\n - api/effects/Effect\n - api/effects/EffectNotification#effect\n - api/effects/createEffect\n - api/effects/ofType\n - api/entity/EntityState\n - api/entity/createEntityAdapter\n - api/store-devtools/DevToolsFeatureOptions#export\n - api/store-devtools/DevToolsFeatureOptions#import\n - api/store-devtools/StoreDevtools#state\n - api/store/Action\n - api/store/Store\n - api/store/StoreModule\n - api/store/createAction\n - api/store/createFeatureSelector\n - api/store/createReducer\n - api/store/createSelector\n - api/store/on\n - api/store/props\n - api/store/testing/MockSelector#selector\n - guide/store/recipes/adding-ngrx-to-existing-apps#adding-ngrx-to-existing-angular-applications\n - guide/store/recipes/adding-ngrx-to-existing-apps#further-changes\n - guide/store/recipes/adding-ngrx-to-existing-apps#how-do-apps-without-ngrx-typically-function\n - guide/store/recipes/adding-ngrx-to-existing-apps#lazy-loading\n - guide/store/recipes/adding-ngrx-to-existing-apps#modifying-the-state\n - guide/store/recipes/adding-ngrx-to-existing-apps#switching-to-ngrx\n - guide/store/recipes/adding-ngrx-to-existing-apps#understanding-how-the-state-can-be-modified\n - guide/store/recipes/adding-ngrx-to-existing-apps#understanding-the-state\n - https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/store/recipes/adding-ngrx-to-existing-apps.md?message=docs%3A%20describe%20your%20change...\n - https://ngrx.io/guide/entity\n-->"
}